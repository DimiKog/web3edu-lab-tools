/* esm.sh - @noble/secp256k1@1.7.1 */
var Tt=Object.defineProperty;var kt=(n,t)=>{for(var e in t)Tt(n,e,{get:t[e],enumerable:!0})};var ft={};kt(ft,{default:()=>Nt});var Nt={};var w=BigInt(0),g=BigInt(1),z=BigInt(2),L=BigInt(3),dt=BigInt(8),y=Object.freeze({a:w,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:g,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),wt=(n,t)=>(n+t/z)/t,J={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(n){let{n:t}=y,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-g*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,i=BigInt("0x100000000000000000000000000000000"),c=wt(o*n,t),u=wt(-r*n,t),f=a(n-c*e-u*s,t),h=a(-c*r-u*o,t),l=f>i,d=h>i;if(l&&(f=t-f),d&&(h=t-h),f>i||h>i)throw new Error("splitScalarEndo: Endomorphism failed, k="+n);return{k1neg:l,k1:f,k2neg:d,k2:h}}},I=32,k=32,bt=32,et=I+1,rt=2*I+1;function yt(n){let{a:t,b:e}=y,r=a(n*n),s=a(r*n);return a(s+t*n+e)}var _=y.a===w,M=class extends Error{constructor(t){super(t)}};function gt(n){if(!(n instanceof E))throw new TypeError("JacobianPoint expected")}var E=class n{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof p))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(p.ZERO)?n.ZERO:new n(t.x,t.y,g)}static toAffineBatch(t){let e=Vt(t.map(r=>r.z));return t.map((r,s)=>r.toAffine(e[s]))}static normalizeZ(t){return n.toAffineBatch(t).map(n.fromAffine)}equals(t){gt(t);let{x:e,y:r,z:s}=this,{x:o,y:i,z:c}=t,u=a(s*s),f=a(c*c),h=a(e*f),l=a(o*u),d=a(a(r*c)*f),x=a(a(i*s)*u);return h===l&&d===x}negate(){return new n(this.x,a(-this.y),this.z)}double(){let{x:t,y:e,z:r}=this,s=a(t*t),o=a(e*e),i=a(o*o),c=t+o,u=a(z*(a(c*c)-s-i)),f=a(L*s),h=a(f*f),l=a(h-z*u),d=a(f*(u-l)-dt*i),x=a(z*e*r);return new n(l,d,x)}add(t){gt(t);let{x:e,y:r,z:s}=this,{x:o,y:i,z:c}=t;if(o===w||i===w)return this;if(e===w||r===w)return t;let u=a(s*s),f=a(c*c),h=a(e*f),l=a(o*u),d=a(a(r*c)*f),x=a(a(i*s)*u),m=a(l-h),B=a(x-d);if(m===w)return B===w?this.double():n.ZERO;let Z=a(m*m),$=a(m*Z),C=a(h*Z),j=a(B*B-$-z*C),at=a(B*(C-j)-d*$),W=a(s*c*m);return new n(j,at,W)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){let e=n.ZERO;if(typeof t=="bigint"&&t===w)return e;let r=xt(t);if(r===g)return this;if(!_){let l=e,d=this;for(;r>w;)r&g&&(l=l.add(d)),d=d.double(),r>>=g;return l}let{k1neg:s,k1:o,k2neg:i,k2:c}=J.splitScalar(r),u=e,f=e,h=this;for(;o>w||c>w;)o&g&&(u=u.add(h)),c&g&&(f=f.add(h)),h=h.double(),o>>=g,c>>=g;return s&&(u=u.negate()),i&&(f=f.negate()),f=new n(a(f.x*J.beta),f.y,f.z),u.add(f)}precomputeWindow(t){let e=_?128/t+1:256/t+1,r=[],s=this,o=s;for(let i=0;i<e;i++){o=s,r.push(o);for(let c=1;c<2**(t-1);c++)o=o.add(s),r.push(o);s=o.double()}return r}wNAF(t,e){!e&&this.equals(n.BASE)&&(e=p.BASE);let r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let s=e&&ut.get(e);s||(s=this.precomputeWindow(r),e&&r!==1&&(s=n.normalizeZ(s),ut.set(e,s)));let o=n.ZERO,i=n.BASE,c=1+(_?128/r:256/r),u=2**(r-1),f=BigInt(2**r-1),h=2**r,l=BigInt(r);for(let d=0;d<c;d++){let x=d*u,m=Number(t&f);t>>=l,m>u&&(m-=h,t+=g);let B=x,Z=x+Math.abs(m)-1,$=d%2!==0,C=m<0;m===0?i=i.add(Q($,s[B])):o=o.add(Q(C,s[Z]))}return{p:o,f:i}}multiply(t,e){let r=xt(t),s,o;if(_){let{k1neg:i,k1:c,k2neg:u,k2:f}=J.splitScalar(r),{p:h,f:l}=this.wNAF(c,e),{p:d,f:x}=this.wNAF(f,e);h=Q(i,h),d=Q(u,d),d=new n(a(d.x*J.beta),d.y,d.z),s=h.add(d),o=l.add(x)}else{let{p:i,f:c}=this.wNAF(r,e);s=i,o=c}return n.normalizeZ([s,o])[0]}toAffine(t){let{x:e,y:r,z:s}=this,o=this.equals(n.ZERO);t==null&&(t=o?dt:K(s));let i=t,c=a(i*i),u=a(c*i),f=a(e*c),h=a(r*u),l=a(s*i);if(o)return p.ZERO;if(l!==g)throw new Error("invZ was invalid");return new p(f,h)}};E.BASE=new E(y.Gx,y.Gy,g);E.ZERO=new E(w,g,w);function Q(n,t){let e=t.negate();return n?e:t}var ut=new WeakMap,p=class n{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,ut.delete(this)}hasEvenY(){return this.y%z===w}static fromCompressedHex(t){let e=t.length===32,r=S(e?t:t.subarray(1));if(!nt(r))throw new Error("Point is not on curve");let s=yt(r),o=Ot(s),i=(o&g)===g;e?i&&(o=a(-o)):(t[0]&1)===1!==i&&(o=a(-o));let c=new n(r,o);return c.assertValidity(),c}static fromUncompressedHex(t){let e=S(t.subarray(1,I+1)),r=S(t.subarray(I+1,I*2+1)),s=new n(e,r);return s.assertValidity(),s}static fromHex(t){let e=H(t),r=e.length,s=e[0];if(r===I)return this.fromCompressedHex(e);if(r===et&&(s===2||s===3))return this.fromCompressedHex(e);if(r===rt&&s===4)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${et} compressed bytes or ${rt} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return n.BASE.multiply(N(t))}static fromSignature(t,e,r){let{r:s,s:o}=vt(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");let i=ht(H(t)),{n:c}=y,u=r===2||r===3?s+c:s,f=K(u,c),h=a(-i*f,c),l=a(o*f,c),d=r&1?"03":"02",x=n.fromHex(d+P(u)),m=n.BASE.multiplyAndAddUnsafe(x,h,l);if(!m)throw new Error("Cannot recover signature: point at infinify");return m.assertValidity(),m}toRawBytes(t=!1){return T(this.toHex(t))}toHex(t=!1){let e=P(this.x);return t?`${this.hasEvenY()?"02":"03"}${e}`:`04${e}${P(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){let t="Point is not on elliptic curve",{x:e,y:r}=this;if(!nt(e)||!nt(r))throw new Error(t);let s=a(r*r),o=yt(e);if(a(s-o)!==w)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new n(this.x,a(-this.y))}double(){return E.fromAffine(this).double().toAffine()}add(t){return E.fromAffine(this).add(E.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return E.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){let s=E.fromAffine(this),o=e===w||e===g||this!==n.BASE?s.multiplyUnsafe(e):s.multiply(e),i=E.fromAffine(t).multiplyUnsafe(r),c=o.add(i);return c.equals(E.ZERO)?void 0:c.toAffine()}};p.BASE=new p(y.Gx,y.Gy);p.ZERO=new p(w,w);function pt(n){return Number.parseInt(n[0],16)>=8?"00"+n:n}function mt(n){if(n.length<2||n[0]!==2)throw new Error(`Invalid signature integer tag: ${D(n)}`);let t=n[1],e=n.subarray(2,t+2);if(!t||e.length!==t)throw new Error("Invalid signature integer: wrong length");if(e[0]===0&&e[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:S(e),left:n.subarray(t+2)}}function Zt(n){if(n.length<2||n[0]!=48)throw new Error(`Invalid signature tag: ${D(n)}`);if(n[1]!==n.length-2)throw new Error("Invalid signature: incorrect length");let{data:t,left:e}=mt(n.subarray(2)),{data:r,left:s}=mt(e);if(s.length)throw new Error(`Invalid signature: left bytes after parsing: ${D(s)}`);return{r:t,s:r}}var O=class n{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){let e=t instanceof Uint8Array,r="Signature.fromCompact";if(typeof t!="string"&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);let s=e?D(t):t;if(s.length!==128)throw new Error(`${r}: Expected 64-byte hex`);return new n(st(s.slice(0,64)),st(s.slice(64,128)))}static fromDER(t){let e=t instanceof Uint8Array;if(typeof t!="string"&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");let{r,s}=Zt(e?t:T(t));return new n(r,s)}static fromHex(t){return this.fromDER(t)}assertValidity(){let{r:t,s:e}=this;if(!q(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!q(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){let t=y.n>>g;return this.s>t}normalizeS(){return this.hasHighS()?new n(this.r,a(-this.s,y.n)):this}toDERRawBytes(){return T(this.toDERHex())}toDERHex(){let t=pt(Y(this.s)),e=pt(Y(this.r)),r=t.length/2,s=e.length/2,o=Y(r),i=Y(s);return`30${Y(s+r+4)}02${i}${e}02${o}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return T(this.toCompactHex())}toCompactHex(){return P(this.r)+P(this.s)}};function U(...n){if(!n.every(r=>r instanceof Uint8Array))throw new Error("Uint8Array list expected");if(n.length===1)return n[0];let t=n.reduce((r,s)=>r+s.length,0),e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){let o=n[r];e.set(o,s),s+=o.length}return e}var $t=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function D(n){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");let t="";for(let e=0;e<n.length;e++)t+=$t[n[e]];return t}var Ct=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function P(n){if(typeof n!="bigint")throw new Error("Expected bigint");if(!(w<=n&&n<Ct))throw new Error("Expected number 0 <= n < 2^256");return n.toString(16).padStart(64,"0")}function X(n){let t=T(P(n));if(t.length!==32)throw new Error("Error: expected 32 bytes");return t}function Y(n){let t=n.toString(16);return t.length&1?`0${t}`:t}function st(n){if(typeof n!="string")throw new TypeError("hexToNumber: expected string, got "+typeof n);return BigInt(`0x${n}`)}function T(n){if(typeof n!="string")throw new TypeError("hexToBytes: expected string, got "+typeof n);if(n.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+n.length);let t=new Uint8Array(n.length/2);for(let e=0;e<t.length;e++){let r=e*2,s=n.slice(r,r+2),o=Number.parseInt(s,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");t[e]=o}return t}function S(n){return st(D(n))}function H(n){return n instanceof Uint8Array?Uint8Array.from(n):T(n)}function xt(n){if(typeof n=="number"&&Number.isSafeInteger(n)&&n>0)return BigInt(n);if(typeof n=="bigint"&&q(n))return n;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function a(n,t=y.P){let e=n%t;return e>=w?e:t+e}function v(n,t){let{P:e}=y,r=n;for(;t-- >w;)r*=r,r%=e;return r}function Ot(n){let{P:t}=y,e=BigInt(6),r=BigInt(11),s=BigInt(22),o=BigInt(23),i=BigInt(44),c=BigInt(88),u=n*n*n%t,f=u*u*n%t,h=v(f,L)*f%t,l=v(h,L)*f%t,d=v(l,z)*u%t,x=v(d,r)*d%t,m=v(x,s)*x%t,B=v(m,i)*m%t,Z=v(B,c)*B%t,$=v(Z,i)*m%t,C=v($,L)*f%t,j=v(C,o)*x%t,at=v(j,e)*u%t,W=v(at,z);if(W*W%t!==n)throw new Error("Cannot find square root");return W}function K(n,t=y.P){if(n===w||t<=w)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=a(n,t),r=t,s=w,o=g,i=g,c=w;for(;e!==w;){let f=r/e,h=r%e,l=s-i*f,d=o-c*f;r=e,e=h,s=i,o=c,i=l,c=d}if(r!==g)throw new Error("invert: does not exist");return a(s,t)}function Vt(n,t=y.P){let e=new Array(n.length),r=n.reduce((o,i,c)=>i===w?o:(e[c]=o,a(o*i,t)),g),s=K(r,t);return n.reduceRight((o,i,c)=>i===w?o:(e[c]=a(o*e[c],t),a(o*i,t)),s),e}function Dt(n){let t=n.length*8-k*8,e=S(n);return t>0?e>>BigInt(t):e}function ht(n,t=!1){let e=Dt(n);if(t)return e;let{n:r}=y;return e>=r?e-r:e}var V,G,ot=class{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return A.hmacSha256(this.k,...t)}hmacSync(...t){return G(this.k,...t)}checkSync(){if(typeof G!="function")throw new M("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),t.length!==0&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),t.length!==0&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0,e=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);let r=this.v.slice();e.push(r),t+=this.v.length}return U(...e)}generateSync(){this.checkSync(),this.incr();let t=0,e=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);let r=this.v.slice();e.push(r),t+=this.v.length}return U(...e)}};function q(n){return w<n&&n<y.n}function nt(n){return w<n&&n<y.P}function St(n,t,e,r=!0){let{n:s}=y,o=ht(n,!0);if(!q(o))return;let i=K(o,s),c=p.BASE.multiply(o),u=a(c.x,s);if(u===w)return;let f=a(i*a(t+e*u,s),s);if(f===w)return;let h=new O(u,f),l=(c.x===h.r?0:2)|Number(c.y&g);return r&&h.hasHighS()&&(h=h.normalizeS(),l^=1),{sig:h,recovery:l}}function N(n){let t;if(typeof n=="bigint")t=n;else if(typeof n=="number"&&Number.isSafeInteger(n)&&n>0)t=BigInt(n);else if(typeof n=="string"){if(n.length!==2*k)throw new Error("Expected 32 bytes of private key");t=st(n)}else if(n instanceof Uint8Array){if(n.length!==k)throw new Error("Expected 32 bytes of private key");t=S(n)}else throw new TypeError("Expected valid private key");if(!q(t))throw new Error("Expected private key: 0 < key < n");return t}function lt(n){return n instanceof p?(n.assertValidity(),n):p.fromHex(n)}function vt(n){if(n instanceof O)return n.assertValidity(),n;try{return O.fromDER(n)}catch{return O.fromCompact(n)}}function Gt(n,t=!1){return p.fromPrivateKey(n).toRawBytes(t)}function Mt(n,t,e,r=!1){return p.fromSignature(n,t,e).toRawBytes(r)}function Et(n){let t=n instanceof Uint8Array,e=typeof n=="string",r=(t||e)&&n.length;return t?r===et||r===rt:e?r===et*2||r===rt*2:n instanceof p}function jt(n,t,e=!1){if(Et(n))throw new TypeError("getSharedSecret: first arg must be private key");if(!Et(t))throw new TypeError("getSharedSecret: second arg must be public key");let r=lt(t);return r.assertValidity(),r.multiply(N(n)).toRawBytes(e)}function At(n){let t=n.length>I?n.slice(0,I):n;return S(t)}function Xt(n){let t=At(n),e=a(t,y.n);return Bt(e<w?t:e)}function Bt(n){return X(n)}function It(n,t,e){if(n==null)throw new Error(`sign: expected valid message hash, not "${n}"`);let r=H(n),s=N(t),o=[Bt(s),Xt(r)];if(e!=null){e===!0&&(e=A.randomBytes(I));let u=H(e);if(u.length!==I)throw new Error(`sign: Expected ${I} bytes of extra data`);o.push(u)}let i=U(...o),c=At(r);return{seed:i,m:c,d:s}}function Ht(n,t){let{sig:e,recovery:r}=n,{der:s,recovered:o}=Object.assign({canonical:!0,der:!0},t),i=s?e.toDERRawBytes():e.toCompactRawBytes();return o?[i,r]:i}async function Jt(n,t,e={}){let{seed:r,m:s,d:o}=It(n,t,e.extraEntropy),i=new ot(bt,k);await i.reseed(r);let c;for(;!(c=St(await i.generate(),s,o,e.canonical));)await i.reseed();return Ht(c,e)}function _t(n,t,e={}){let{seed:r,m:s,d:o}=It(n,t,e.extraEntropy),i=new ot(bt,k);i.reseedSync(r);let c;for(;!(c=St(i.generateSync(),s,o,e.canonical));)i.reseedSync();return Ht(c,e)}var qt={strict:!0};function Qt(n,t,e,r=qt){let s;try{s=vt(n),t=H(t)}catch{return!1}let{r:o,s:i}=s;if(r.strict&&s.hasHighS())return!1;let c=ht(t),u;try{u=lt(e)}catch{return!1}let{n:f}=y,h=K(i,f),l=a(c*h,f),d=a(o*h,f),x=p.BASE.multiplyAndAddUnsafe(u,l,d);return x?a(x.x,f)===o:!1}function it(n){return a(S(n),y.n)}var F=class n{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){let e=H(t);if(e.length!==64)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);let r=S(e.subarray(0,32)),s=S(e.subarray(32,64));return new n(r,s)}assertValidity(){let{r:t,s:e}=this;if(!nt(t)||!q(e))throw new Error("Invalid signature")}toHex(){return P(this.r)+P(this.s)}toRawBytes(){return T(this.toHex())}};function Ft(n){return p.fromPrivateKey(n).toRawX()}var ct=class{constructor(t,e,r=A.randomBytes()){if(t==null)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=H(t);let{x:s,scalar:o}=this.getScalar(N(e));if(this.px=s,this.d=o,this.rand=H(r),this.rand.length!==32)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){let e=p.fromPrivateKey(t),r=e.hasEvenY()?t:y.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return X(t^S(e))}finalizeNonce(t){let e=a(S(t),y.n);if(e===w)throw new Error("sign: Creation of signature failed. k is zero");let{point:r,x:s,scalar:o}=this.getScalar(e);return{R:r,rx:s,k:o}}finalizeSig(t,e,r,s){return new F(t.x,a(e+r*s,y.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){let{m:t,d:e,px:r,rand:s}=this,o=A.taggedHash,i=this.initNonce(e,await o(R.aux,s)),{R:c,rx:u,k:f}=this.finalizeNonce(await o(R.nonce,i,r,t)),h=it(await o(R.challenge,u,r,t)),l=this.finalizeSig(c,f,h,e);return await zt(l,t,r)||this.error(),l}calcSync(){let{m:t,d:e,px:r,rand:s}=this,o=A.taggedHashSync,i=this.initNonce(e,o(R.aux,s)),{R:c,rx:u,k:f}=this.finalizeNonce(o(R.nonce,i,r,t)),h=it(o(R.challenge,u,r,t)),l=this.finalizeSig(c,f,h,e);return Pt(l,t,r)||this.error(),l}};async function Kt(n,t,e){return new ct(n,t,e).calc()}function Wt(n,t,e){return new ct(n,t,e).calcSync()}function Rt(n,t,e){let r=n instanceof F,s=r?n:F.fromHex(n);return r&&s.assertValidity(),{...s,m:H(t),P:lt(e)}}function Ut(n,t,e,r){let s=p.BASE.multiplyAndAddUnsafe(t,N(e),a(-r,y.n));return!(!s||!s.hasEvenY()||s.x!==n)}async function zt(n,t,e){try{let{r,s,m:o,P:i}=Rt(n,t,e),c=it(await A.taggedHash(R.challenge,X(r),i.toRawX(),o));return Ut(r,i,s,c)}catch{return!1}}function Pt(n,t,e){try{let{r,s,m:o,P:i}=Rt(n,t,e),c=it(A.taggedHashSync(R.challenge,X(r),i.toRawX(),o));return Ut(r,i,s,c)}catch(r){if(r instanceof M)throw r;return!1}}var tn={Signature:F,getPublicKey:Ft,sign:Kt,verify:zt,signSync:Wt,verifySync:Pt};p.BASE._setWindowSize(8);var b={node:ft,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},R={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},tt={},A={bytesToHex:D,hexToBytes:T,concatBytes:U,mod:a,invert:K,isValidPrivateKey(n){try{return N(n),!0}catch{return!1}},_bigintTo32Bytes:X,_normalizePrivateKey:N,hashToPrivateKey:n=>{n=H(n);let t=k+8;if(n.length<t||n.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");let e=a(S(n),y.n-g)+g;return X(e)},randomBytes:(n=32)=>{if(b.web)return b.web.getRandomValues(new Uint8Array(n));if(b.node){let{randomBytes:t}=b.node;return Uint8Array.from(t(n))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>A.hashToPrivateKey(A.randomBytes(k+8)),precompute(n=8,t=p.BASE){let e=t===p.BASE?t:new p(t.x,t.y);return e._setWindowSize(n),e.multiply(L),e},sha256:async(...n)=>{if(b.web){let t=await b.web.subtle.digest("SHA-256",U(...n));return new Uint8Array(t)}else if(b.node){let{createHash:t}=b.node,e=t("sha256");return n.forEach(r=>e.update(r)),Uint8Array.from(e.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(n,...t)=>{if(b.web){let e=await b.web.subtle.importKey("raw",n,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=U(...t),s=await b.web.subtle.sign("HMAC",e,r);return new Uint8Array(s)}else if(b.node){let{createHmac:e}=b.node,r=e("sha256",n);return t.forEach(s=>r.update(s)),Uint8Array.from(r.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(n,...t)=>{let e=tt[n];if(e===void 0){let r=await A.sha256(Uint8Array.from(n,s=>s.charCodeAt(0)));e=U(r,r),tt[n]=e}return A.sha256(e,...t)},taggedHashSync:(n,...t)=>{if(typeof V!="function")throw new M("sha256Sync is undefined, you need to set it");let e=tt[n];if(e===void 0){let r=V(Uint8Array.from(n,s=>s.charCodeAt(0)));e=U(r,r),tt[n]=e}return V(e,...t)},_JacobianPoint:E};Object.defineProperties(A,{sha256Sync:{configurable:!1,get(){return V},set(n){V||(V=n)}},hmacSha256Sync:{configurable:!1,get(){return G},set(n){G||(G=n)}}});export{y as CURVE,p as Point,O as Signature,Gt as getPublicKey,jt as getSharedSecret,Mt as recoverPublicKey,tn as schnorr,Jt as sign,_t as signSync,A as utils,Qt as verify};
/*! Bundled license information:

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=secp256k1.bundle.mjs.map