/* esm.sh - @noble/hashes@1.3.3/hmac */
function a(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function y(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function p(t,...e){if(!y(t))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function h(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");a(t.outputLen),a(t.blockLen)}function f(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function w(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}var g=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!g)throw new Error("Non little-endian hardware is not supported");function x(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function d(t){if(typeof t=="string"&&(t=x(t)),!w(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}var c=class{clone(){return this._cloneInto()}},E={}.toString;var u=class extends c{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,h(e);let i=d(r);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,n=new Uint8Array(s);n.set(i.length>s?e.create().update(i).digest():i);for(let o=0;o<n.length;o++)n[o]^=54;this.iHash.update(n),this.oHash=e.create();for(let o=0;o<n.length;o++)n[o]^=106;this.oHash.update(n),n.fill(0)}update(e){return f(this),this.iHash.update(e),this}digestInto(e){f(this),p(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:r,iHash:i,finished:s,destroyed:n,blockLen:o,outputLen:l}=this;return e=e,e.finished=s,e.destroyed=n,e.blockLen=o,e.outputLen=l,e.oHash=r._cloneInto(e.oHash),e.iHash=i._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},b=(t,e,r)=>new u(t,e).update(r).digest();b.create=(t,e)=>new u(t,e);export{u as HMAC,b as hmac};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=hmac.bundle.mjs.map